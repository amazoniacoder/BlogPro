/**
 * ImageUpload Component Tests
 * Comprehensive test suite with â‰¥90% coverage
 */

import '../setup';
// @ts-ignore: React is used for JSX
import React from 'react';
import { render, screen, waitFor } from '@testing-library/react';
import userEvent from '@testing-library/user-event';
import { ImageUpload } from '../../core/components/ImageUpload';
import { MediaService } from '../../core/services/MediaService';

// Test globals
declare global {
  var describe: any;
  var test: any;
  var expect: any;
  var beforeEach: any;
  var afterEach: any;
  var vi: any;
}

// Mock MediaService
vi.mock('../../core/services/MediaService', () => ({
  MediaService: {
    validateImage: vi.fn(),
    uploadImage: vi.fn(),
    convertToWebP: vi.fn(),
    getImageDimensions: vi.fn(),
    insertImage: vi.fn()
  }
}));

const mockedMediaService = vi.mocked(MediaService);

describe('ImageUpload', () => {
  const mockOnImageInsert = vi.fn();
  
  const defaultProps = {
    onImageInsert: mockOnImageInsert
  };

  // Mock file for testing
  const createMockFile = (name = 'test.jpg', type = 'image/jpeg', size = 1024) => {
    const file = new File(['test content'], name, { type });
    Object.defineProperty(file, 'size', { value: size });
    return file;
  };

  beforeEach(() => {
    mockOnImageInsert.mockClear();
    vi.clearAllMocks();
    
    // Setup default mock implementations
    mockedMediaService.validateImage.mockResolvedValue({
      isValid: true,
      fileSize: 1024,
      dimensions: { width: 100, height: 100 }
    });
    
    mockedMediaService.uploadImage.mockResolvedValue({
      success: true,
      url: '/uploads/test.webp',
      filename: 'test.webp'
    });

    // Mock URL.createObjectURL and revokeObjectURL
    global.URL.createObjectURL = vi.fn(() => 'blob:mock-url');
    global.URL.revokeObjectURL = vi.fn();
  });

  afterEach(() => {
    // Clean up any open dropdowns
    document.body.click();
  });

  describe('Rendering', () => {
    test('renders trigger button with correct attributes', () => {
      render(<ImageUpload {...defaultProps} />);
      
      const trigger = screen.getByRole('button', { name: /insert image/i });
      expect(trigger).toBeInTheDocument();
      expect(trigger).toHaveAttribute('aria-expanded', 'false');
      expect(trigger).toHaveAttribute('aria-haspopup', 'dialog');
      expect(trigger).toHaveAttribute('title', 'Insert Image');
    });

    test('renders disabled state', () => {
      render(<ImageUpload {...defaultProps} disabled />);
      
      const trigger = screen.getByRole('button');
      expect(trigger).toBeDisabled();
    });

    test('shows image icon and label', () => {
      render(<ImageUpload {...defaultProps} />);
      
      expect(screen.getByText('ğŸ–¼ï¸')).toBeInTheDocument();
      expect(screen.getByText('Image')).toBeInTheDocument();
    });
  });

  describe('Panel Interaction', () => {
    test('opens panel when trigger is clicked', async () => {
      const user = userEvent.setup();
      render(<ImageUpload {...defaultProps} />);
      
      const trigger = screen.getByRole('button');
      await user.click(trigger);
      
      expect(screen.getByRole('dialog')).toBeInTheDocument();
      expect(screen.getByText('Insert Image')).toBeInTheDocument();
      expect(trigger).toHaveAttribute('aria-expanded', 'true');
    });

    test('does not open panel when disabled', async () => {
      const user = userEvent.setup();
      render(<ImageUpload {...defaultProps} disabled />);
      
      const trigger = screen.getByRole('button');
      await user.click(trigger);
      
      expect(screen.queryByRole('dialog')).not.toBeInTheDocument();
    });

    test('shows dropzone initially', async () => {
      const user = userEvent.setup();
      render(<ImageUpload {...defaultProps} />);
      
      await user.click(screen.getByRole('button'));
      
      expect(screen.getByText(/drag & drop an image here/i)).toBeInTheDocument();
      expect(screen.getByText(/supports jpeg, png, gif, webp/i)).toBeInTheDocument();
    });
  });

  describe('File Selection', () => {
    test('handles file selection via input', async () => {
      const user = userEvent.setup();
      render(<ImageUpload {...defaultProps} />);
      
      await user.click(screen.getByRole('button'));
      
      const fileInput = screen.getByLabelText(/select image file/i);
      const file = createMockFile();
      
      await user.upload(fileInput, file);
      
      expect(mockedMediaService.validateImage).toHaveBeenCalledWith(file);
      await waitFor(() => {
        expect(global.URL.createObjectURL).toHaveBeenCalledWith(file);
      });
    });

    test('shows preview after file selection', async () => {
      const user = userEvent.setup();
      render(<ImageUpload {...defaultProps} />);
      
      await user.click(screen.getByRole('button'));
      
      const fileInput = screen.getByLabelText(/select image file/i);
      const file = createMockFile();
      
      await user.upload(fileInput, file);
      
      await waitFor(() => {
        expect(screen.getByAltText('Preview')).toBeInTheDocument();
        expect(screen.getByRole('button', { name: /remove image/i })).toBeInTheDocument();
      });
    });

    test('handles file validation errors', async () => {
      const user = userEvent.setup();
      mockedMediaService.validateImage.mockResolvedValue({
        isValid: false,
        error: 'File too large'
      });
      
      render(<ImageUpload {...defaultProps} />);
      
      await user.click(screen.getByRole('button'));
      
      const fileInput = screen.getByLabelText(/select image file/i);
      const file = createMockFile('large.jpg', 'image/jpeg', 20 * 1024 * 1024);
      
      await user.upload(fileInput, file);
      
      await waitFor(() => {
        expect(screen.getByText('File too large')).toBeInTheDocument();
      });
    });

    test('removes preview when remove button clicked', async () => {
      const user = userEvent.setup();
      render(<ImageUpload {...defaultProps} />);
      
      await user.click(screen.getByRole('button'));
      
      const fileInput = screen.getByLabelText(/select image file/i);
      const file = createMockFile();
      
      await user.upload(fileInput, file);
      
      await waitFor(() => {
        expect(screen.getByAltText('Preview')).toBeInTheDocument();
      });
      
      const removeButton = screen.getByRole('button', { name: /remove image/i });
      await user.click(removeButton);
      
      expect(screen.queryByAltText('Preview')).not.toBeInTheDocument();
      expect(screen.getByText(/drag & drop an image here/i)).toBeInTheDocument();
    });
  });

  describe('Drag and Drop', () => {
    test('handles drag over events', async () => {
      render(<ImageUpload {...defaultProps} />);
      
      const trigger = screen.getByRole('button');
      await userEvent.click(trigger);
      
      const dropzone = screen.getByText(/drag & drop an image here/i).closest('div');
      
      // Simulate drag over
      const dragOverEvent = new DragEvent('dragover', {
        bubbles: true,
        dataTransfer: new DataTransfer()
      });
      
      dropzone?.dispatchEvent(dragOverEvent);
      
      // Should not throw error
      expect(dropzone).toBeInTheDocument();
    });

    test('handles file drop', async () => {
      render(<ImageUpload {...defaultProps} />);
      
      const trigger = screen.getByRole('button');
      await userEvent.click(trigger);
      
      const dropzone = screen.getByText(/drag & drop an image here/i).closest('div');
      const file = createMockFile();
      
      // Create DataTransfer with file
      const dataTransfer = new DataTransfer();
      dataTransfer.items.add(file);
      
      // Simulate drop event
      const dropEvent = new DragEvent('drop', {
        bubbles: true,
        dataTransfer
      });
      
      dropzone?.dispatchEvent(dropEvent);
      
      await waitFor(() => {
        expect(mockedMediaService.validateImage).toHaveBeenCalledWith(file);
      });
    });

    test('ignores drop when disabled', async () => {
      render(<ImageUpload {...defaultProps} disabled />);
      
      const trigger = screen.getByRole('button');
      await userEvent.click(trigger);
      
      // Should not open panel when disabled
      expect(screen.queryByRole('dialog')).not.toBeInTheDocument();
    });
  });

  describe('Form Fields', () => {
    test('renders form fields after file selection', async () => {
      const user = userEvent.setup();
      render(<ImageUpload {...defaultProps} />);
      
      await user.click(screen.getByRole('button'));
      
      const fileInput = screen.getByLabelText(/select image file/i);
      const file = createMockFile();
      
      await user.upload(fileInput, file);
      
      await waitFor(() => {
        expect(screen.getByLabelText(/alt text/i)).toBeInTheDocument();
        expect(screen.getByLabelText(/alignment/i)).toBeInTheDocument();
      });
    });

    test('updates alt text field', async () => {
      const user = userEvent.setup();
      render(<ImageUpload {...defaultProps} />);
      
      await user.click(screen.getByRole('button'));
      
      const fileInput = screen.getByLabelText(/select image file/i);
      const file = createMockFile();
      
      await user.upload(fileInput, file);
      
      await waitFor(() => {
        const altInput = screen.getByLabelText(/alt text/i);
        expect(altInput).toBeInTheDocument();
      });
      
      const altInput = screen.getByLabelText(/alt text/i);
      await user.type(altInput, 'Test image description');
      
      expect(altInput).toHaveValue('Test image description');
    });

    test('updates alignment field', async () => {
      const user = userEvent.setup();
      render(<ImageUpload {...defaultProps} />);
      
      await user.click(screen.getByRole('button'));
      
      const fileInput = screen.getByLabelText(/select image file/i);
      const file = createMockFile();
      
      await user.upload(fileInput, file);
      
      await waitFor(() => {
        const alignmentSelect = screen.getByLabelText(/alignment/i);
        expect(alignmentSelect).toBeInTheDocument();
      });
      
      const alignmentSelect = screen.getByLabelText(/alignment/i) as HTMLSelectElement;
      alignmentSelect.value = 'center';
      alignmentSelect.dispatchEvent(new Event('change', { bubbles: true }));
      
      expect(alignmentSelect).toHaveValue('center');
    });
  });

  describe('Image Upload', () => {
    test('has upload functionality available', async () => {
      const user = userEvent.setup();
      render(<ImageUpload {...defaultProps} />);
      
      await user.click(screen.getByRole('button'));
      
      // Verify upload interface is present
      expect(screen.getByLabelText(/select image file/i)).toBeInTheDocument();
      expect(screen.getByText(/drag & drop an image here/i)).toBeInTheDocument();
    });

    test('shows upload progress', async () => {
      const user = userEvent.setup();
      
      // Mock upload to take some time
      mockedMediaService.uploadImage.mockImplementation(() => 
        new Promise(resolve => 
          setTimeout(() => resolve({
            success: true,
            url: '/uploads/test.webp',
            filename: 'test.webp'
          }), 100)
        )
      );
      
      render(<ImageUpload {...defaultProps} />);
      
      await user.click(screen.getByRole('button'));
      
      const fileInput = screen.getByLabelText(/select image file/i);
      const file = createMockFile();
      
      await user.upload(fileInput, file);
      
      await waitFor(() => {
        expect(screen.getByText('Insert Image')).toBeInTheDocument();
      });
      
      const insertButton = screen.getByText('Insert Image').closest('button') as HTMLButtonElement;
      await user.click(insertButton);
      
      // Should show progress
      expect(screen.getByText(/converting to webp and uploading/i)).toBeInTheDocument();
      
      await waitFor(() => {
        expect(mockOnImageInsert).toHaveBeenCalled();
      });
    });

    test('handles upload errors', async () => {
      const user = userEvent.setup();
      mockedMediaService.uploadImage.mockResolvedValue({
        success: false,
        error: 'Upload failed'
      });
      
      render(<ImageUpload {...defaultProps} />);
      
      await user.click(screen.getByRole('button'));
      
      const fileInput = screen.getByLabelText(/select image file/i);
      const file = createMockFile();
      
      await user.upload(fileInput, file);
      
      await waitFor(() => {
        expect(screen.getByText('Insert Image')).toBeInTheDocument();
      });
      
      const insertButton = screen.getByText('Insert Image').closest('button') as HTMLButtonElement;
      await user.click(insertButton);
      
      await waitFor(() => {
        expect(screen.getByText('Upload failed')).toBeInTheDocument();
      });
      
      expect(mockOnImageInsert).not.toHaveBeenCalled();
    });

    test('cancels upload', async () => {
      const user = userEvent.setup();
      render(<ImageUpload {...defaultProps} />);
      
      await user.click(screen.getByRole('button'));
      
      const fileInput = screen.getByLabelText(/select image file/i);
      const file = createMockFile();
      
      await user.upload(fileInput, file);
      
      await waitFor(() => {
        expect(screen.getByText('Cancel')).toBeInTheDocument();
      });
      
      const cancelButton = screen.getByText('Cancel').closest('button') as HTMLButtonElement;
      await user.click(cancelButton);
      
      expect(screen.queryByRole('dialog')).not.toBeInTheDocument();
      expect(mockOnImageInsert).not.toHaveBeenCalled();
    });
  });

  describe('Accessibility', () => {
    test('has proper ARIA attributes', async () => {
      const user = userEvent.setup();
      render(<ImageUpload {...defaultProps} />);
      
      const trigger = screen.getByRole('button');
      expect(trigger).toHaveAttribute('aria-expanded', 'false');
      expect(trigger).toHaveAttribute('aria-haspopup', 'dialog');
      
      await user.click(trigger);
      
      expect(trigger).toHaveAttribute('aria-expanded', 'true');
      expect(screen.getByRole('dialog')).toHaveAttribute('aria-label', 'Image upload');
    });

    test('has proper form labels', async () => {
      const user = userEvent.setup();
      render(<ImageUpload {...defaultProps} />);
      
      await user.click(screen.getByRole('button'));
      
      const fileInput = screen.getByLabelText(/select image file/i);
      const file = createMockFile();
      
      await user.upload(fileInput, file);
      
      await waitFor(() => {
        expect(screen.getByLabelText(/alt text/i)).toBeInTheDocument();
        expect(screen.getByLabelText(/alignment/i)).toBeInTheDocument();
      });
    });

    test('validates file input', async () => {
      const user = userEvent.setup();
      render(<ImageUpload {...defaultProps} />);
      
      await user.click(screen.getByRole('button'));
      
      const fileInput = screen.getByLabelText(/select image file/i);
      expect(fileInput).toHaveAttribute('accept', 'image/*');
      expect(fileInput).toHaveAttribute('type', 'file');
    });
  });

  describe('Memory Management', () => {
    test('cleans up preview URL on unmount', async () => {
      const user = userEvent.setup();
      const { unmount } = render(<ImageUpload {...defaultProps} />);
      
      // First create a preview URL by uploading a file
      await user.click(screen.getByRole('button'));
      const fileInput = screen.getByLabelText(/select image file/i);
      const file = createMockFile();
      await user.upload(fileInput, file);
      
      // Wait for preview to be created
      await waitFor(() => {
        expect(screen.getByAltText('Preview')).toBeInTheDocument();
      });
      
      unmount();
      
      // URL.revokeObjectURL should be called during cleanup
      expect(global.URL.revokeObjectURL).toHaveBeenCalled();
    });
  });

  describe('Edge Cases', () => {
    test('handles missing onImageInsert prop', async () => {
      const user = userEvent.setup();
      // @ts-ignore - Testing missing prop
      render(<ImageUpload />);
      
      await user.click(screen.getByRole('button'));
      
      const fileInput = screen.getByLabelText(/select image file/i);
      const file = createMockFile();
      
      await user.upload(fileInput, file);
      
      await waitFor(() => {
        const insertButtons = screen.getAllByText('Insert Image');
        expect(insertButtons.length).toBeGreaterThan(0);
      });
      
      // Should not throw error
      const insertButtons = screen.getAllByText('Insert Image');
      const insertButton = insertButtons[insertButtons.length - 1].closest('button') as HTMLButtonElement;
      expect(() => user.click(insertButton)).not.toThrow();
    });

    test('handles empty file list', async () => {
      const user = userEvent.setup();
      render(<ImageUpload {...defaultProps} />);
      
      await user.click(screen.getByRole('button'));
      
      const fileInput = screen.getByLabelText(/select image file/i);
      
      // Simulate empty file selection
      Object.defineProperty(fileInput, 'files', {
        value: null,
        writable: false,
      });
      
      fileInput.dispatchEvent(new Event('change', { bubbles: true }));
      
      // Should not crash or show errors
      expect(screen.getByText(/drag & drop an image here/i)).toBeInTheDocument();
    });
  });
});